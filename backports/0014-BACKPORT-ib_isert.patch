From: Max Gurtovoy <maxg@mellanox.com>
Subject: [PATCH] BACKPORT: ib_isert

Change-Id: I1799473e4814f3b2e8d7ce73dad987d76a04be06
Signed-off-by: Max Gurtovoy <maxg@mellanox.com>
---
 drivers/infiniband/ulp/isert/ib_isert.c  |  332 ++++++++++++++++++++++++++++++
 drivers/infiniband/ulp/isert/ib_isert.h  |    4 +
 drivers/target/iscsi/iscsi_target_core.h |   72 +++++++
 include/target/iscsi/iscsi_transport.h   |   29 +++
 4 files changed, 437 insertions(+), 0 deletions(-)

diff --git a/drivers/infiniband/ulp/isert/ib_isert.c b/drivers/infiniband/ulp/isert/ib_isert.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/infiniband/ulp/isert/ib_isert.c
+++ b/drivers/infiniband/ulp/isert/ib_isert.c
@@ -46,6 +46,9 @@ static DEFINE_MUTEX(device_list_mutex);
 static LIST_HEAD(device_list);
 static struct workqueue_struct *isert_comp_wq;
 static struct workqueue_struct *isert_release_wq;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+static struct kmem_cache *isert_cmd_cache;
+#endif
 
 static void
 isert_unmap_cmd(struct isert_cmd *isert_cmd, struct isert_conn *isert_conn);
@@ -68,8 +71,12 @@ struct rdma_cm_id *isert_setup_id(struct isert_np *isert_np);
 static inline bool
 isert_prot_cmd(struct isert_conn *conn, struct se_cmd *cmd)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 	return (conn->pi_support &&
 		cmd->prot_op != TARGET_PROT_NORMAL);
+#else
+	return false;
+#endif
 }
 
 
@@ -429,6 +436,7 @@ isert_conn_free_fastreg_pool(struct isert_conn *isert_conn)
 			isert_conn->conn_fr_pool_size - i);
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 static int
 isert_create_pi_ctx(struct fast_reg_descriptor *desc,
 		    struct ib_device *device,
@@ -488,6 +496,7 @@ err_pi_ctx:
 
 	return ret;
 }
+#endif
 
 static int
 isert_create_fr_desc(struct ib_device *ib_device, struct ib_pd *pd,
@@ -579,6 +588,7 @@ isert_connect_request(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)
 	struct ib_device *ib_dev = cma_id->device;
 	int ret = 0;
 
+#if defined(CONFIG_COMPAT_RHEL_7_1) || defined(CONFIG_COMPAT_SLES_12_0) || defined(CONFIG_COMPAT_FBK_16) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 	spin_lock_bh(&np->np_thread_lock);
 	if (!np->enabled) {
 		spin_unlock_bh(&np->np_thread_lock);
@@ -586,6 +596,7 @@ isert_connect_request(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)
 		return rdma_reject(cma_id, NULL, 0);
 	}
 	spin_unlock_bh(&np->np_thread_lock);
+#endif
 
 	isert_dbg("cma_id: %p, portal: %p\n",
 		 cma_id, cma_id->context);
@@ -1184,13 +1195,35 @@ isert_rx_login_req(struct isert_conn *isert_conn)
 		  MAX_KEY_VALUE_PAIRS);
 	memcpy(login->req_buf, &rx_desc->data[0], size);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	if (login->first_request) {
 		complete(&isert_conn->conn_login_comp);
 		return;
 	}
 	schedule_delayed_work(&conn->login_work, 0);
+#else
+	complete(&isert_conn->conn_login_comp);
+#endif
 }
 
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+static void
+isert_release_cmd(struct iscsi_cmd *cmd)
+{
+        struct isert_cmd *isert_cmd = container_of(cmd, struct isert_cmd,
+                                                   iscsi_cmd);
+
+        pr_debug("Entering isert_release_cmd %p >>>>>>>>>>>>>>>.\n", isert_cmd);
+
+        kfree(cmd->buf_ptr);
+        kfree(cmd->tmr_req);
+
+        kmem_cache_free(isert_cmd_cache, isert_cmd);
+}
+#endif
+
+#if defined(CONFIG_COMPAT_SLES_12_0) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0))
 static struct iscsi_cmd
 *isert_allocate_cmd(struct iscsi_conn *conn)
 {
@@ -1209,6 +1242,43 @@ static struct iscsi_cmd
 
 	return cmd;
 }
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
+static struct iscsi_cmd
+*isert_allocate_cmd(struct iscsi_conn *conn, gfp_t gfp)
+{
+	struct isert_conn *isert_conn = (struct isert_conn *)conn->context;
+	struct isert_cmd *isert_cmd;
+	struct iscsi_cmd *cmd;
+
+	cmd = iscsit_allocate_cmd(conn, gfp);
+	if (!cmd) {
+		isert_err("Unable to allocate iscsi_cmd + isert_cmd\n");
+		return NULL;
+	}
+	isert_cmd = iscsit_priv_cmd(cmd);
+	isert_cmd->conn = isert_conn;
+	isert_cmd->iscsi_cmd = cmd;
+
+	return cmd;
+}
+#else
+static struct iscsi_cmd
+*isert_alloc_cmd(struct iscsi_conn *conn, gfp_t gfp)
+{
+        struct isert_conn *isert_conn = (struct isert_conn *)conn->context;
+        struct isert_cmd *isert_cmd;
+
+        isert_cmd = kmem_cache_zalloc(isert_cmd_cache, gfp);
+        if (!isert_cmd) {
+                pr_err("Unable to allocate isert_cmd\n");
+                return NULL;
+        }
+        isert_cmd->conn = isert_conn;
+        isert_cmd->iscsi_cmd.release_cmd = &isert_release_cmd;
+
+        return &isert_cmd->iscsi_cmd;
+}
+#endif
 
 static int
 isert_handle_scsi_cmd(struct isert_conn *isert_conn,
@@ -1324,6 +1394,7 @@ isert_handle_iscsi_dataout(struct isert_conn *isert_conn,
 	return 0;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 static int
 isert_handle_nop_out(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd,
 		     struct iscsi_cmd *cmd, struct iser_rx_desc *rx_desc,
@@ -1342,7 +1413,29 @@ isert_handle_nop_out(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd,
 
 	return iscsit_process_nop_out(conn, cmd, hdr);
 }
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
+static int
+isert_handle_nop_out(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd,
+		     struct iser_rx_desc *rx_desc, unsigned char *buf)
+{
+	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
+	struct iscsi_conn *conn = isert_conn->conn;
+	struct iscsi_nopout *hdr = (struct iscsi_nopout *)buf;
+	int rc;
 
+	rc = iscsit_setup_nop_out(conn, cmd, hdr);
+	if (rc < 0)
+		return rc;
+	/*
+	 * FIXME: Add support for NOPOUT payload using unsolicited RDMA payload
+	 */
+
+	return iscsit_process_nop_out(conn, cmd, hdr);
+}
+#endif
+
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 static int
 isert_handle_text_cmd(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd,
 		      struct iscsi_cmd *cmd, struct iser_rx_desc *rx_desc,
@@ -1369,6 +1462,35 @@ isert_handle_text_cmd(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd
 
 	return iscsit_process_text_cmd(conn, cmd, hdr);
 }
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
+static int
+isert_handle_text_cmd(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd,
+		      struct iser_rx_desc *rx_desc,
+		      struct iscsi_text *hdr)
+{
+	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
+	struct iscsi_conn *conn = isert_conn->conn;
+	u32 payload_length = ntoh24(hdr->dlength);
+	int rc;
+	unsigned char *text_in;
+
+	rc = iscsit_setup_text_cmd(conn, cmd, hdr);
+	if (rc < 0)
+		return rc;
+
+	text_in = kzalloc(payload_length, GFP_KERNEL);
+	if (!text_in) {
+		isert_err("Unable to allocate text_in of payload_length: %u\n",
+			  payload_length);
+		return -ENOMEM;
+	}
+	cmd->text_in_ptr = text_in;
+
+	memcpy(cmd->text_in_ptr, &rx_desc->data[0], payload_length);
+
+	return iscsit_process_text_cmd(conn, cmd, hdr);
+}
+#endif
 
 static int
 isert_rx_opcode(struct isert_conn *isert_conn, struct iser_rx_desc *rx_desc,
@@ -1392,11 +1514,21 @@ isert_rx_opcode(struct isert_conn *isert_conn, struct iser_rx_desc *rx_desc,
 
 	switch (opcode) {
 	case ISCSI_OP_SCSI_CMD:
+#if defined(CONFIG_COMPAT_SLES_12_0) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0))
 		cmd = isert_allocate_cmd(conn);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
+		cmd = isert_allocate_cmd(conn, GFP_KERNEL);
+#else
+		cmd = iscsit_allocate_cmd(conn, GFP_KERNEL);
+#endif
 		if (!cmd)
 			break;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 		isert_cmd = iscsit_priv_cmd(cmd);
+#else
+		isert_cmd = container_of(cmd, struct isert_cmd, iscsi_cmd);
+#endif
 		isert_cmd->read_stag = read_stag;
 		isert_cmd->read_va = read_va;
 		isert_cmd->write_stag = write_stag;
@@ -1406,20 +1538,40 @@ isert_rx_opcode(struct isert_conn *isert_conn, struct iser_rx_desc *rx_desc,
 					rx_desc, (unsigned char *)hdr);
 		break;
 	case ISCSI_OP_NOOP_OUT:
+#if defined(CONFIG_COMPAT_SLES_12_0) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0))
 		cmd = isert_allocate_cmd(conn);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
+		cmd = isert_allocate_cmd(conn, GFP_KERNEL);
+#else
+		cmd = iscsit_allocate_cmd(conn, GFP_KERNEL);
+#endif
 		if (!cmd)
 			break;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 		isert_cmd = iscsit_priv_cmd(cmd);
 		ret = isert_handle_nop_out(isert_conn, isert_cmd, cmd,
 					   rx_desc, (unsigned char *)hdr);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
+		isert_cmd = container_of(cmd, struct isert_cmd, iscsi_cmd);
+		ret = isert_handle_nop_out(isert_conn, isert_cmd,
+					   rx_desc, (unsigned char *)hdr);
+#else
+		ret = iscsit_handle_nop_out(conn, cmd, (unsigned char *)hdr);
+#endif
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
 		ret = isert_handle_iscsi_dataout(isert_conn, rx_desc,
 						(unsigned char *)hdr);
 		break;
 	case ISCSI_OP_SCSI_TMFUNC:
+#if defined(CONFIG_COMPAT_SLES_12_0) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0))
 		cmd = isert_allocate_cmd(conn);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
+		cmd = isert_allocate_cmd(conn, GFP_KERNEL);
+#else
+		cmd = iscsit_allocate_cmd(conn, GFP_KERNEL);
+#endif
 		if (!cmd)
 			break;
 
@@ -1427,20 +1579,38 @@ isert_rx_opcode(struct isert_conn *isert_conn, struct iser_rx_desc *rx_desc,
 						(unsigned char *)hdr);
 		break;
 	case ISCSI_OP_LOGOUT:
+#if defined(CONFIG_COMPAT_SLES_12_0) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0))
 		cmd = isert_allocate_cmd(conn);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
+		cmd = isert_allocate_cmd(conn, GFP_KERNEL);
+#else
+		cmd = iscsit_allocate_cmd(conn, GFP_KERNEL);
+#endif
 		if (!cmd)
 			break;
 
 		ret = iscsit_handle_logout_cmd(conn, cmd, (unsigned char *)hdr);
 		break;
 	case ISCSI_OP_TEXT:
+#if defined(CONFIG_COMPAT_SLES_12_0) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0))
 		cmd = isert_allocate_cmd(conn);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
+		cmd = isert_allocate_cmd(conn, GFP_KERNEL);
+#else
+		cmd = iscsit_allocate_cmd(conn, GFP_KERNEL);
+#endif
 		if (!cmd)
 			break;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 		isert_cmd = iscsit_priv_cmd(cmd);
 		ret = isert_handle_text_cmd(isert_conn, isert_cmd, cmd,
 					    rx_desc, (struct iscsi_text *)hdr);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
+		isert_cmd = container_of(cmd, struct isert_cmd, iscsi_cmd);
+		ret = isert_handle_text_cmd(isert_conn, isert_cmd,
+					    rx_desc, (struct iscsi_text *)hdr);
+#endif
 		break;
 	default:
 		isert_err("Got unknown iSCSI OpCode: 0x%02x\n", opcode);
@@ -1654,7 +1824,11 @@ isert_unreg_rdma(struct isert_cmd *isert_cmd, struct isert_conn *isert_conn)
 static void
 isert_put_cmd(struct isert_cmd *isert_cmd, bool comp_err)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct iscsi_cmd *cmd = isert_cmd->iscsi_cmd;
+#else
+	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
+#endif
 	struct isert_conn *isert_conn = isert_cmd->conn;
 	struct iscsi_conn *conn = isert_conn->conn;
 	struct isert_device *device = isert_conn->conn_device;
@@ -1719,7 +1893,11 @@ isert_put_cmd(struct isert_cmd *isert_cmd, bool comp_err)
 		 * Fall-through
 		 */
 	default:
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 		iscsit_release_cmd(cmd);
+#else
+		isert_release_cmd(cmd);
+#endif
 		break;
 	}
 }
@@ -1750,6 +1928,7 @@ isert_completion_put(struct iser_tx_desc *tx_desc, struct isert_cmd *isert_cmd,
 	isert_put_cmd(isert_cmd, comp_err);
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 static int
 isert_check_pi_status(struct se_cmd *se_cmd, struct ib_mr *sig_mr)
 {
@@ -1793,16 +1972,24 @@ isert_check_pi_status(struct se_cmd *se_cmd, struct ib_mr *sig_mr)
 fail_mr_status:
 	return ret;
 }
+#endif
 
 static void
 isert_completion_rdma_write(struct iser_tx_desc *tx_desc,
 			    struct isert_cmd *isert_cmd)
 {
 	struct isert_rdma_wr *wr = &isert_cmd->rdma_wr;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct iscsi_cmd *cmd = isert_cmd->iscsi_cmd;
+#else
+	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 	struct se_cmd *se_cmd = &cmd->se_cmd;
+#endif
 	struct isert_conn *isert_conn = isert_cmd->conn;
 	struct isert_device *device = isert_conn->conn_device;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 	int ret = 0;
 
 	if (wr->fr_desc && wr->fr_desc->ind & ISERT_PROTECTED) {
@@ -1810,14 +1997,19 @@ isert_completion_rdma_write(struct iser_tx_desc *tx_desc,
 					    wr->fr_desc->pi_ctx->sig_mr);
 		wr->fr_desc->ind &= ~ISERT_PROTECTED;
 	}
+#endif
 
 	device->unreg_rdma_mem(isert_cmd, isert_conn);
 	wr->send_wr_num = 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 	if (ret)
 		transport_send_check_condition_and_sense(se_cmd,
 							 se_cmd->pi_err, 0);
 	else
 		isert_put_response(isert_conn->conn, cmd);
+#else
+	isert_put_response(isert_conn->conn, cmd);
+#endif
 }
 
 static void
@@ -1825,10 +2017,15 @@ isert_completion_rdma_read(struct iser_tx_desc *tx_desc,
 			   struct isert_cmd *isert_cmd)
 {
 	struct isert_rdma_wr *wr = &isert_cmd->rdma_wr;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct iscsi_cmd *cmd = isert_cmd->iscsi_cmd;
+#else
+	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
+#endif
 	struct se_cmd *se_cmd = &cmd->se_cmd;
 	struct isert_conn *isert_conn = isert_cmd->conn;
 	struct isert_device *device = isert_conn->conn_device;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 	int ret = 0;
 
 	if (wr->fr_desc && wr->fr_desc->ind & ISERT_PROTECTED) {
@@ -1836,6 +2033,7 @@ isert_completion_rdma_read(struct iser_tx_desc *tx_desc,
 					    wr->fr_desc->pi_ctx->sig_mr);
 		wr->fr_desc->ind &= ~ISERT_PROTECTED;
 	}
+#endif
 
 	iscsit_stop_dataout_timer(cmd);
 	device->unreg_rdma_mem(isert_cmd, isert_conn);
@@ -1848,11 +2046,15 @@ isert_completion_rdma_read(struct iser_tx_desc *tx_desc,
 	cmd->i_state = ISTATE_RECEIVED_LAST_DATAOUT;
 	spin_unlock_bh(&cmd->istate_lock);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 	if (ret)
 		transport_send_check_condition_and_sense(se_cmd,
 							 se_cmd->pi_err, 0);
 	else
 		target_execute_cmd(se_cmd);
+#else
+	target_execute_cmd(se_cmd);
+#endif
 }
 
 static void
@@ -1862,7 +2064,11 @@ isert_do_control_comp(struct work_struct *work)
 			struct isert_cmd, comp_work);
 	struct isert_conn *isert_conn = isert_cmd->conn;
 	struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct iscsi_cmd *cmd = isert_cmd->iscsi_cmd;
+#else
+	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
+#endif
 
 	isert_dbg("Cmd %p i_state %d\n", isert_cmd, cmd->i_state);
 
@@ -1891,7 +2097,11 @@ isert_response_completion(struct iser_tx_desc *tx_desc,
 			  struct isert_conn *isert_conn,
 			  struct ib_device *ib_dev)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct iscsi_cmd *cmd = isert_cmd->iscsi_cmd;
+#else
+	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
+#endif
 
 	if (cmd->i_state == ISTATE_SEND_TASKMGTRSP ||
 	    cmd->i_state == ISTATE_SEND_LOGOUTRSP ||
@@ -2069,7 +2279,12 @@ isert_post_response(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd)
 static int
 isert_put_response(struct iscsi_conn *conn, struct iscsi_cmd *cmd)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_conn *isert_conn = (struct isert_conn *)conn->context;
 	struct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;
 	struct iscsi_scsi_rsp *hdr = (struct iscsi_scsi_rsp *)
@@ -2114,6 +2329,7 @@ isert_put_response(struct iscsi_conn *conn, struct iscsi_cmd *cmd)
 	return isert_post_response(isert_conn, isert_cmd);
 }
 
+#if defined(CONFIG_COMPAT_ISCSIT_ABORTED_TASK)
 static void
 isert_aborted_task(struct iscsi_conn *conn, struct iscsi_cmd *cmd)
 {
@@ -2131,11 +2347,14 @@ isert_aborted_task(struct iscsi_conn *conn, struct iscsi_cmd *cmd)
 
 	device->unreg_rdma_mem(isert_cmd, isert_conn);
 }
+#endif
 
+#if defined(CONFIG_COMPAT_ISCSIT_GET_SUP_PROT_OPS)
 static enum target_prot_op
 isert_get_sup_prot_ops(struct iscsi_conn *conn)
 {
 	struct isert_conn *isert_conn = (struct isert_conn *)conn->context;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 	struct isert_device *device = isert_conn->conn_device;
 
 	if (conn->tpg->tpg_attrib.t10_pi) {
@@ -2145,18 +2364,25 @@ isert_get_sup_prot_ops(struct iscsi_conn *conn)
 			return TARGET_PROT_ALL;
 		}
 	}
+#endif
 
 	isert_info("conn %p PI offload disabled\n", isert_conn);
 	isert_conn->pi_support = false;
 
 	return TARGET_PROT_NORMAL;
 }
+#endif
 
 static int
 isert_put_nopin(struct iscsi_cmd *cmd, struct iscsi_conn *conn,
 		bool nopout_response)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_conn *isert_conn = (struct isert_conn *)conn->context;
 	struct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;
 
@@ -2175,7 +2401,12 @@ isert_put_nopin(struct iscsi_cmd *cmd, struct iscsi_conn *conn,
 static int
 isert_put_logout_rsp(struct iscsi_cmd *cmd, struct iscsi_conn *conn)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_conn *isert_conn = (struct isert_conn *)conn->context;
 	struct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;
 
@@ -2193,7 +2424,12 @@ isert_put_logout_rsp(struct iscsi_cmd *cmd, struct iscsi_conn *conn)
 static int
 isert_put_tm_rsp(struct iscsi_cmd *cmd, struct iscsi_conn *conn)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_conn *isert_conn = (struct isert_conn *)conn->context;
 	struct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;
 
@@ -2211,7 +2447,12 @@ isert_put_tm_rsp(struct iscsi_cmd *cmd, struct iscsi_conn *conn)
 static int
 isert_put_reject(struct iscsi_cmd *cmd, struct iscsi_conn *conn)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_conn *isert_conn = (struct isert_conn *)conn->context;
 	struct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;
 	struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
@@ -2240,10 +2481,16 @@ isert_put_reject(struct iscsi_cmd *cmd, struct iscsi_conn *conn)
 	return isert_post_response(isert_conn, isert_cmd);
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
 static int
 isert_put_text_rsp(struct iscsi_cmd *cmd, struct iscsi_conn *conn)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_conn *isert_conn = (struct isert_conn *)conn->context;
 	struct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;
 	struct iscsi_text_rsp *hdr =
@@ -2279,13 +2526,18 @@ isert_put_text_rsp(struct iscsi_cmd *cmd, struct iscsi_conn *conn)
 
 	return isert_post_response(isert_conn, isert_cmd);
 }
+#endif
 
 static int
 isert_build_rdma_wr(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd,
 		    struct ib_sge *ib_sge, struct ib_send_wr *send_wr,
 		    u32 data_left, u32 offset)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct iscsi_cmd *cmd = isert_cmd->iscsi_cmd;
+#else
+	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
+#endif
 	struct scatterlist *sg_start, *tmp_sg;
 	struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
 	u32 sg_off, page_off;
@@ -2332,7 +2584,12 @@ isert_map_rdma(struct iscsi_conn *conn, struct iscsi_cmd *cmd,
 	       struct isert_rdma_wr *wr)
 {
 	struct se_cmd *se_cmd = &cmd->se_cmd;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_conn *isert_conn = (struct isert_conn *)conn->context;
 	struct isert_data_buf *data = &wr->data;
 	struct ib_send_wr *send_wr;
@@ -2546,6 +2803,7 @@ isert_fast_reg_mr(struct isert_conn *isert_conn,
 	return ret;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 static inline void
 isert_set_dif_domain(struct se_cmd *se_cmd, struct ib_sig_attrs *sig_attrs,
 		     struct ib_sig_domain *domain)
@@ -2566,7 +2824,9 @@ isert_set_dif_domain(struct se_cmd *se_cmd, struct ib_sig_attrs *sig_attrs,
 	    se_cmd->prot_type == TARGET_DIF_TYPE2_PROT)
 		domain->sig.dif.ref_remap = true;
 };
+#endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 static int
 isert_set_sig_attrs(struct se_cmd *se_cmd, struct ib_sig_attrs *sig_attrs)
 {
@@ -2725,13 +2985,19 @@ unmap_prot_cmd:
 
 	return ret;
 }
+#endif
 
 static int
 isert_reg_rdma(struct iscsi_conn *conn, struct iscsi_cmd *cmd,
 	       struct isert_rdma_wr *wr)
 {
 	struct se_cmd *se_cmd = &cmd->se_cmd;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_conn *isert_conn = conn->context;
 	struct fast_reg_descriptor *fr_desc = NULL;
 	struct ib_send_wr *send_wr;
@@ -2764,9 +3030,11 @@ isert_reg_rdma(struct iscsi_conn *conn, struct iscsi_cmd *cmd,
 		goto unmap_cmd;
 
 	if (isert_prot_cmd(isert_conn, se_cmd)) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 		ret = isert_handle_prot_cmd(isert_conn, isert_cmd, wr);
 		if (ret)
 			goto unmap_cmd;
+#endif
 
 		ib_sg = &wr->ib_sg[SIG];
 	} else {
@@ -2814,7 +3082,12 @@ static int
 isert_put_datain(struct iscsi_conn *conn, struct iscsi_cmd *cmd)
 {
 	struct se_cmd *se_cmd = &cmd->se_cmd;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_rdma_wr *wr = &isert_cmd->rdma_wr;
 	struct isert_conn *isert_conn = (struct isert_conn *)conn->context;
 	struct isert_device *device = isert_conn->conn_device;
@@ -2864,7 +3137,12 @@ static int
 isert_get_dataout(struct iscsi_conn *conn, struct iscsi_cmd *cmd, bool recovery)
 {
 	struct se_cmd *se_cmd = &cmd->se_cmd;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_rdma_wr *wr = &isert_cmd->rdma_wr;
 	struct isert_conn *isert_conn = (struct isert_conn *)conn->context;
 	struct isert_device *device = isert_conn->conn_device;
@@ -2929,9 +3207,11 @@ isert_response_queue(struct iscsi_conn *conn, struct iscsi_cmd *cmd, int state)
 	case ISTATE_SEND_REJECT:
 		ret = isert_put_reject(cmd, conn);
 		break;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
 	case ISTATE_SEND_TEXTRSP:
 		ret = isert_put_text_rsp(cmd, conn);
 		break;
+#endif
 	case ISTATE_SEND_STATUS:
 		/*
 		 * Special case for sending non GOOD SCSI status from TX thread
@@ -3262,6 +3542,7 @@ isert_wait4flush(struct isert_conn *isert_conn)
 	wait_for_completion(&isert_conn->conn_wait_comp_err);
 }
 
+#if defined(CONFIG_COMPAT_ISCSIT_WAIT_CONN)
 static void isert_wait_conn(struct iscsi_conn *conn)
 {
 	struct isert_conn *isert_conn = conn->context;
@@ -3287,24 +3568,53 @@ static void isert_wait_conn(struct iscsi_conn *conn)
 	INIT_WORK(&isert_conn->release_work, isert_release_work);
 	queue_work(isert_release_wq, &isert_conn->release_work);
 }
+#endif /* CONFIG_COMPAT_ISCSIT_WAIT_CONN */
 
 static void isert_free_conn(struct iscsi_conn *conn)
 {
 	struct isert_conn *isert_conn = conn->context;
 
+#if !defined(CONFIG_COMPAT_ISCSIT_WAIT_CONN)
+	mutex_lock(&isert_conn->conn_mutex);
+	/*
+	 * Only wait for conn_wait_comp_err if the isert_conn made it
+	 * into full feature phase..
+	 */
+	if (isert_conn->state == ISER_CONN_INIT) {
+		mutex_unlock(&isert_conn->conn_mutex);
+		goto out;
+	}
+	isert_conn_terminate(isert_conn);
+	mutex_unlock(&isert_conn->conn_mutex);
+
+	isert_wait4cmds(conn);
+	isert_wait4flush(isert_conn);
+	isert_wait4logout(isert_conn);
+
+	INIT_WORK(&isert_conn->release_work, isert_release_work);
+	queue_work(isert_release_wq, &isert_conn->release_work);
+out:
+#endif /* CONFIG_COMPAT_ISCSIT_WAIT_CONN */
 	isert_put_conn(isert_conn);
 }
 
 static struct iscsit_transport iser_target_transport = {
 	.name			= "IB/iSER",
 	.transport_type		= ISCSI_INFINIBAND,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	.priv_size		= sizeof(struct isert_cmd),
+#endif
 	.owner			= THIS_MODULE,
 	.iscsit_setup_np	= isert_setup_np,
 	.iscsit_accept_np	= isert_accept_np,
 	.iscsit_free_np		= isert_free_np,
+#if defined(CONFIG_COMPAT_ISCSIT_WAIT_CONN)
 	.iscsit_wait_conn	= isert_wait_conn,
+#endif /* CONFIG_COMPAT_ISCSIT_WAIT_CONN */
 	.iscsit_free_conn	= isert_free_conn,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+	.iscsit_alloc_cmd       = isert_alloc_cmd,
+#endif
 	.iscsit_get_login_rx	= isert_get_login_rx,
 	.iscsit_put_login_tx	= isert_put_login_tx,
 	.iscsit_immediate_queue	= isert_immediate_queue,
@@ -3312,8 +3622,12 @@ static struct iscsit_transport iser_target_transport = {
 	.iscsit_get_dataout	= isert_get_dataout,
 	.iscsit_queue_data_in	= isert_put_datain,
 	.iscsit_queue_status	= isert_put_response,
+#if defined(CONFIG_COMPAT_ISCSIT_ABORTED_TASK)
 	.iscsit_aborted_task	= isert_aborted_task,
+#endif
+#if defined(CONFIG_COMPAT_ISCSIT_GET_SUP_PROT_OPS)
 	.iscsit_get_sup_prot_ops = isert_get_sup_prot_ops,
+#endif
 };
 
 static int __init isert_init(void)
@@ -3335,11 +3649,26 @@ static int __init isert_init(void)
 		goto destroy_comp_wq;
 	}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+        isert_cmd_cache = kmem_cache_create("isert_cmd_cache",
+                        sizeof(struct isert_cmd), __alignof__(struct isert_cmd),
+                        0, NULL);
+        if (!isert_cmd_cache) {
+                pr_err("Unable to create isert_cmd_cache\n");
+                ret = -ENOMEM;
+                goto destroy_release_wq;
+        }
+#endif
+
 	iscsit_register_transport(&iser_target_transport);
 	isert_info("iSER_TARGET[0] - Loaded iser_target_transport\n");
 
 	return 0;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+destroy_release_wq:
+	destroy_workqueue(isert_release_wq);
+#endif
 destroy_comp_wq:
 	destroy_workqueue(isert_comp_wq);
 
@@ -3348,6 +3677,9 @@ destroy_comp_wq:
 
 static void __exit isert_exit(void)
 {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+	kmem_cache_destroy(isert_cmd_cache);
+#endif
 	flush_scheduled_work();
 	destroy_workqueue(isert_release_wq);
 	destroy_workqueue(isert_comp_wq);
diff --git a/drivers/infiniband/ulp/isert/ib_isert.h b/drivers/infiniband/ulp/isert/ib_isert.h
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/infiniband/ulp/isert/ib_isert.h
+++ b/drivers/infiniband/ulp/isert/ib_isert.h
@@ -139,7 +139,11 @@ struct isert_cmd {
 	u32			write_va_off;
 	u32			rdma_wr_num;
 	struct isert_conn	*conn;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct iscsi_cmd	*iscsi_cmd;
+#else
+	struct iscsi_cmd	iscsi_cmd;
+#endif
 	struct iser_tx_desc	tx_desc;
 	struct isert_rdma_wr	rdma_wr;
 	struct work_struct	comp_work;
diff --git a/drivers/target/iscsi/iscsi_target_core.h b/drivers/target/iscsi/iscsi_target_core.h
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/target/iscsi/iscsi_target_core.h
+++ b/drivers/target/iscsi/iscsi_target_core.h
@@ -37,6 +37,9 @@
 #define NA_RANDOM_DATAIN_PDU_OFFSETS	0
 #define NA_RANDOM_DATAIN_SEQ_OFFSETS	0
 #define NA_RANDOM_R2T_OFFSETS		0
+#define NA_DEFAULT_ERL			0
+#define NA_DEFAULT_ERL_MAX		2
+#define NA_DEFAULT_ERL_MIN		0
 
 /* struct iscsi_tpg_attrib sanity values */
 #define TA_AUTHENTICATION		1
@@ -47,7 +50,11 @@
 #define TA_NETIF_TIMEOUT_MAX		15
 #define TA_NETIF_TIMEOUT_MIN		2
 #define TA_GENERATE_NODE_ACLS		0
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+#define TA_DEFAULT_CMDSN_DEPTH		16
+#else
 #define TA_DEFAULT_CMDSN_DEPTH		64
+#endif
 #define TA_DEFAULT_CMDSN_DEPTH_MAX	512
 #define TA_DEFAULT_CMDSN_DEPTH_MIN	1
 #define TA_CACHE_DYNAMIC_ACLS		0
@@ -434,8 +441,10 @@ struct iscsi_cmd {
 	u32			tx_size;
 	/* Buffer used for various purposes */
 	void			*buf_ptr;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
 	/* Used by SendTargets=[iqn.,eui.] discovery */
 	void			*text_in_ptr;
+#endif
 	/* See include/linux/dma-mapping.h */
 	enum dma_data_direction	data_direction;
 	/* iSCSI PDU Header + CRC */
@@ -493,6 +502,9 @@ struct iscsi_cmd {
 	u32			first_data_sg_off;
 	u32			kmapped_nents;
 	sense_reason_t		sense_reason;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+	void (*release_cmd)(struct iscsi_cmd *);
+#endif
 }  ____cacheline_aligned;
 
 struct iscsi_tmr_req {
@@ -535,6 +547,10 @@ struct iscsi_conn {
 	u32			of_marker;
 	/* Used for calculating OFMarker offset to next PDU */
 	u32			of_marker_offset;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0))
+	/* Complete Bad PDU for sending reject */
+	unsigned char		bad_hdr[ISCSI_HDR_LEN];
+#endif
 #define IPV6_ADDRESS_SPACE				48
 	unsigned char		login_ip[IPV6_ADDRESS_SPACE];
 	unsigned char		local_ip[IPV6_ADDRESS_SPACE];
@@ -557,7 +573,12 @@ struct iscsi_conn {
 	struct completion	rx_half_close_comp;
 	/* socket used by this connection */
 	struct socket		*sock;
+#if defined(CONFIG_COMPAT_SLES_12_0) || defined(CONFIG_COMPAT_UBUNTU_14_4)
+	void                    (*orig_data_ready)(struct sock *, int);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	void			(*orig_data_ready)(struct sock *);
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	void			(*orig_state_change)(struct sock *);
 #define LOGIN_FLAGS_READ_ACTIVE		1
 #define LOGIN_FLAGS_CLOSED		2
@@ -566,10 +587,13 @@ struct iscsi_conn {
 	struct delayed_work	login_work;
 	struct delayed_work	login_cleanup_work;
 	struct iscsi_login	*login;
+#endif
 	struct timer_list	nopin_timer;
 	struct timer_list	nopin_response_timer;
 	struct timer_list	transport_timer;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct task_struct	*login_kworker;
+#endif
 	/* Spinlock used for add/deleting cmd's from conn_cmd_list */
 	spinlock_t		cmd_lock;
 	spinlock_t		conn_usage_lock;
@@ -597,7 +621,9 @@ struct iscsi_conn {
 	void			*context;
 	struct iscsi_login_thread_s *login_thread;
 	struct iscsi_portal_group *tpg;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct iscsi_tpg_np	*tpg_np;
+#endif
 	/* Pointer to parent session */
 	struct iscsi_session	*sess;
 	/* Pointer to thread_set in use for this conn's threads */
@@ -651,13 +677,25 @@ struct iscsi_session {
 	/* Used for session reference counting */
 	int			session_usage_count;
 	int			session_waiting_on_uc;
+#if defined(CONFIG_COMPAT_SLES_12_0) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,13,0))
 	atomic_long_t		cmd_pdus;
 	atomic_long_t		rsp_pdus;
 	atomic_long_t		tx_data_octets;
 	atomic_long_t		rx_data_octets;
 	atomic_long_t		conn_digest_errors;
 	atomic_long_t		conn_timeout_errors;
+#else
+	u32			cmd_pdus;
+	u32			rsp_pdus;
+	u64			tx_data_octets;
+	u64			rx_data_octets;
+	u32			conn_digest_errors;
+	u32			conn_timeout_errors;
+#endif
 	u64			creation_time;
+#if !defined(CONFIG_COMPAT_SLES_12_0) && (LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0))
+	spinlock_t              session_stats_lock;
+#endif
 	/* Number of active connections */
 	atomic_t		nconn;
 	atomic_t		session_continuation;
@@ -695,7 +733,9 @@ struct iscsi_login {
 	u8 version_max;
 	u8 login_complete;
 	u8 login_failed;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	bool zero_tsih;
+#endif
 	char isid[6];
 	u32 cmd_sn;
 	itt_t init_task_tag;
@@ -708,7 +748,9 @@ struct iscsi_login {
 	char *req_buf;
 	char *rsp_buf;
 	struct iscsi_conn *conn;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct iscsi_np *np;
+#endif
 } ____cacheline_aligned;
 
 struct iscsi_node_attrib {
@@ -755,6 +797,11 @@ struct iscsi_node_acl {
 	struct se_node_acl	se_node_acl;
 };
 
+#define NODE_STAT_GRPS(nacl)	(&(nacl)->node_stat_grps)
+
+#define ISCSI_NODE_ATTRIB(t)	(&(t)->node_attrib)
+#define ISCSI_NODE_AUTH(t)	(&(t)->node_auth)
+
 struct iscsi_tpg_attrib {
 	u32			authentication;
 	u32			login_timeout;
@@ -764,9 +811,13 @@ struct iscsi_tpg_attrib {
 	u32			default_cmdsn_depth;
 	u32			demo_mode_write_protect;
 	u32			prod_mode_write_protect;
+#if defined(CONFIG_COMPAT_SLES_12_0) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,13,0))
 	u32			demo_mode_discovery;
 	u32			default_erl;
+#endif
+#if defined(CONFIG_COMPAT_ISCSIT_GET_SUP_PROT_OPS)
 	u8			t10_pi;
+#endif
 	struct iscsi_portal_group *tpg;
 };
 
@@ -775,7 +826,9 @@ struct iscsi_np {
 	int			np_ip_proto;
 	int			np_sock_type;
 	enum np_thread_state_table np_thread_state;
+#if defined(CONFIG_COMPAT_RHEL_7_1) || defined(CONFIG_COMPAT_SLES_12_0) || defined(CONFIG_COMPAT_FBK_16) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 	bool                    enabled;
+#endif
 	enum iscsi_timer_flags_table np_login_timer_flags;
 	u32			np_exports;
 	enum np_flags_table	np_flags;
@@ -787,10 +840,15 @@ struct iscsi_np {
 	struct __kernel_sockaddr_storage np_sockaddr;
 	struct task_struct	*np_thread;
 	struct timer_list	np_login_timer;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+	struct iscsi_portal_group *np_login_tpg;
+#endif
 	void			*np_context;
 	struct iscsit_transport *np_transport;
 	struct list_head	np_list;
+#if defined(CONFIG_COMPAT_SLES_12_0) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 	struct iscsi_tpg_np	*tpg_np;
+#endif
 } ____cacheline_aligned;
 
 struct iscsi_tpg_np {
@@ -802,8 +860,10 @@ struct iscsi_tpg_np {
 	struct list_head	tpg_np_parent_list;
 	struct se_tpg_np	se_tpg_np;
 	spinlock_t		tpg_np_parent_lock;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct completion	tpg_np_comp;
 	struct kref		tpg_np_kref;
+#endif
 };
 
 struct iscsi_portal_group {
@@ -825,7 +885,11 @@ struct iscsi_portal_group {
 	spinlock_t		tpg_state_lock;
 	struct se_portal_group tpg_se_tpg;
 	struct mutex		tpg_access_lock;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct semaphore	np_login_sem;
+#else
+	struct mutex            np_login_lock;
+#endif
 	struct iscsi_tpg_attrib	tpg_attrib;
 	struct iscsi_node_auth	tpg_demo_auth;
 	/* Pointer to default list of iSCSI parameters for TPG */
@@ -835,6 +899,12 @@ struct iscsi_portal_group {
 	struct list_head	tpg_list;
 } ____cacheline_aligned;
 
+#define ISCSI_TPG_C(c)		((struct iscsi_portal_group *)(c)->tpg)
+#define ISCSI_TPG_LUN(c, l)  ((iscsi_tpg_list_t *)(c)->tpg->tpg_lun_list_t[l])
+#define ISCSI_TPG_S(s)		((struct iscsi_portal_group *)(s)->tpg)
+#define ISCSI_TPG_ATTRIB(t)	(&(t)->tpg_attrib)
+#define SE_TPG(tpg)		(&(tpg)->tpg_se_tpg)
+
 struct iscsi_wwn_stat_grps {
 	struct config_group	iscsi_stat_group;
 	struct config_group	iscsi_instance_group;
@@ -865,6 +935,8 @@ struct iscsi_tiqn {
 	struct iscsi_logout_stats    logout_stats;
 } ____cacheline_aligned;
 
+#define WWN_STAT_GRPS(tiqn)   (&(tiqn)->tiqn_stat_grps)
+
 struct iscsit_global {
 	/* In core shutdown */
 	u32			in_shutdown;
diff --git a/include/target/iscsi/iscsi_transport.h b/include/target/iscsi/iscsi_transport.h
index xxxxxxx..xxxxxxx xxxxxx
--- a/include/target/iscsi/iscsi_transport.h
+++ b/include/target/iscsi/iscsi_transport.h
@@ -6,14 +6,21 @@ struct iscsit_transport {
 #define ISCSIT_TRANSPORT_NAME	16
 	char name[ISCSIT_TRANSPORT_NAME];
 	int transport_type;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	int priv_size;
+#endif
 	struct module *owner;
 	struct list_head t_node;
 	int (*iscsit_setup_np)(struct iscsi_np *, struct __kernel_sockaddr_storage *);
 	int (*iscsit_accept_np)(struct iscsi_np *, struct iscsi_conn *);
 	void (*iscsit_free_np)(struct iscsi_np *);
+#if defined(CONFIG_COMPAT_ISCSIT_WAIT_CONN)
 	void (*iscsit_wait_conn)(struct iscsi_conn *);
+#endif /* CONFIG_COMPAT_ISCSIT_WAIT_CONN */
 	void (*iscsit_free_conn)(struct iscsi_conn *);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+	struct iscsi_cmd *(*iscsit_alloc_cmd)(struct iscsi_conn *, gfp_t);
+#endif
 	int (*iscsit_get_login_rx)(struct iscsi_conn *, struct iscsi_login *);
 	int (*iscsit_put_login_tx)(struct iscsi_conn *, struct iscsi_login *, u32);
 	int (*iscsit_immediate_queue)(struct iscsi_conn *, struct iscsi_cmd *, int);
@@ -21,14 +28,20 @@ struct iscsit_transport {
 	int (*iscsit_get_dataout)(struct iscsi_conn *, struct iscsi_cmd *, bool);
 	int (*iscsit_queue_data_in)(struct iscsi_conn *, struct iscsi_cmd *);
 	int (*iscsit_queue_status)(struct iscsi_conn *, struct iscsi_cmd *);
+#if defined(CONFIG_COMPAT_ISCSIT_ABORTED_TASK)
 	void (*iscsit_aborted_task)(struct iscsi_conn *, struct iscsi_cmd *);
+#endif
+#if defined(CONFIG_COMPAT_ISCSIT_GET_SUP_PROT_OPS)
 	enum target_prot_op (*iscsit_get_sup_prot_ops)(struct iscsi_conn *);
+#endif
 };
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 static inline void *iscsit_priv_cmd(struct iscsi_cmd *cmd)
 {
 	return (void *)(cmd + 1);
 }
+#endif
 
 /*
  * From iscsi_target_transport.c
@@ -42,6 +55,10 @@ extern void iscsit_put_transport(struct iscsit_transport *);
 /*
  * From iscsi_target.c
  */
+#if !defined(CONFIG_COMPAT_FBK_16) && (LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0))
+extern int iscsit_add_reject_from_cmd(u8, int, int, unsigned char *,
+				struct iscsi_cmd *);
+#endif
 extern int iscsit_setup_scsi_cmd(struct iscsi_conn *, struct iscsi_cmd *,
 				unsigned char *);
 extern void iscsit_set_unsoliticed_dataout(struct iscsi_cmd *);
@@ -51,27 +68,37 @@ extern int iscsit_check_dataout_hdr(struct iscsi_conn *, unsigned char *,
 				struct iscsi_cmd **);
 extern int iscsit_check_dataout_payload(struct iscsi_cmd *, struct iscsi_data *,
 				bool);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0))
+extern int iscsit_handle_nop_out(struct iscsi_conn *, struct iscsi_cmd *,
+				unsigned char *);
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
 extern int iscsit_setup_nop_out(struct iscsi_conn *, struct iscsi_cmd *,
 				struct iscsi_nopout *);
 extern int iscsit_process_nop_out(struct iscsi_conn *, struct iscsi_cmd *,
 				struct iscsi_nopout *);
+#endif
 extern int iscsit_handle_logout_cmd(struct iscsi_conn *, struct iscsi_cmd *,
 				unsigned char *);
 extern int iscsit_handle_task_mgt_cmd(struct iscsi_conn *, struct iscsi_cmd *,
 				unsigned char *);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
 extern int iscsit_setup_text_cmd(struct iscsi_conn *, struct iscsi_cmd *,
 				 struct iscsi_text *);
 extern int iscsit_process_text_cmd(struct iscsi_conn *, struct iscsi_cmd *,
 				   struct iscsi_text *);
+#endif
 extern void iscsit_build_rsp_pdu(struct iscsi_cmd *, struct iscsi_conn *,
 				bool, struct iscsi_scsi_rsp *);
 extern void iscsit_build_nopin_rsp(struct iscsi_cmd *, struct iscsi_conn *,
 				struct iscsi_nopin *, bool);
 extern void iscsit_build_task_mgt_rsp(struct iscsi_cmd *, struct iscsi_conn *,
 				struct iscsi_tm_rsp *);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
 extern int iscsit_build_text_rsp(struct iscsi_cmd *, struct iscsi_conn *,
 				struct iscsi_text_rsp *,
 				enum iscsit_transport_type);
+#endif
 extern void iscsit_build_reject(struct iscsi_cmd *, struct iscsi_conn *,
 				struct iscsi_reject *);
 extern int iscsit_build_logout_rsp(struct iscsi_cmd *, struct iscsi_conn *,
@@ -101,4 +128,6 @@ extern int iscsit_tmr_post_handler(struct iscsi_cmd *, struct iscsi_conn *);
 extern struct iscsi_cmd *iscsit_allocate_cmd(struct iscsi_conn *, int);
 extern int iscsit_sequence_cmd(struct iscsi_conn *, struct iscsi_cmd *,
 			       unsigned char *, __be32);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 extern void iscsit_release_cmd(struct iscsi_cmd *);
+#endif
